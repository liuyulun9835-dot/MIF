# MIF架构决策记录 (ADR)

> **Architecture Decision Records** - 记录"为什么"而非"是什么"  
> **用途**: 让未来的自己和新AI理解决策的trade-off

---

## ADR模板

```markdown
## ADR-XXX: [决策标题]

**日期**: YYYY-MM-DD  
**状态**: ✅ Accepted | 🔄 Proposed | ❌ Rejected | ⚠️ Deprecated  
**决策者**: [姓名/AI]

### 上下文 (Context)
[描述需要做决策的背景和问题]

### 决策 (Decision)
[描述最终采用的方案]

### 理由 (Rationale)
[解释为什么选择这个方案]
1. [理由1]
2. [理由2]
3. [理由3]

### 后果 (Consequences)
**正面**:
- [好处1]
- [好处2]

**负面**:
- [代价1]
- [代价2]

### 替代方案 (Alternatives Considered)
**方案A**: [描述]
- 优点: [...]
- 缺点: [...]
- 为什么拒绝: [...]

**方案B**: [描述]
- 优点: [...]
- 缺点: [...]
- 为什么拒绝: [...]

### 验证方法 (Validation)
- [ ] [如何证明这个决策是对的]
- [ ] [可证伪的测试方法]

### 实施计划 (Implementation)
- Phase 1: [...]
- Phase 2: [...]

### 重新评估条件 (Reconsideration Triggers)
- 如果[条件1],则重新考虑
- 如果[条件2],则重新考虑
```

---

## ADR-001: E从单值升级为三维矢量

**日期**: 2025-11-09  
**状态**: ✅ Accepted  
**决策者**: Severi + Claude

### 上下文

**问题**:
- 当前E是单一标量值 (E ∈ ℝ)
- 回测结果: 54%无成本胜率 → 18bp成本后 → 10.5%胜率
- 分析: 438笔交易中,80%被18bp成本磨损吃掉

**根因分析**:
```
E > 0.40 只告诉我们"有推动"
但不告诉我们"推力是否足够强覆盖成本"

类比:
知道"车在动" ≠ 知道"车速是否足够快到达目的地"
```

**关键洞察**:
- 前10%胜手: 200bp盈利,MAE 20bp → 高质量信号
- 后90%: 被磨损吃掉 → 低质量信号
- 需要在开仓前就区分质量

### 决策

**采用方案**: E三维矢量化
```python
E = (direction, magnitude, quality)

direction: sgn(delta_trade)  # 推动方向 ∈ {-1, 0, +1}
magnitude: |z(delta_trade)|  # 推动强度 ∈ [0, ∞)
quality: f(CVD_slope, DEPIN, large_trade_pct)  # 质量 ∈ [0, 1]
```

### 理由

**1. 符合策略信条3: 矢量优于标量**
- 方向信息与强度信息不可分离
- 单一数值丢失关键维度
- 三维向量保留完整信息

**2. quality维度可过滤低质量信号**
```python
# 当前 (标量)
if E > 0.40:  # 100个信号
    开仓  # 80个被磨损

# 改进 (矢量)
if E.magnitude > 0.40 and E.quality > quantile(0.80):  # 20个信号
    开仓  # 预期15-20个有效
```

**3. 从拍卖理论获得质量评估能力**
- CVD_slope: 累积压力的持续性
- DEPIN: 单位成交的方向集中度
- large_trade_pct: 大单参与度 (机构 vs 散户)

**4. 可证伪性强**
```
假设: E.quality与后续收益正相关
验证: corr(E.quality, returns) > 0.3 (p < 0.05)
证伪: 如果相关性 < 0.1 → 质量维度无效 → 回退方案
```

### 后果

**正面**:
- ✅ 预期减少80%交易量 (400 → 80)
- ✅ 预期胜率提升 (10.5% → 25%+)
- ✅ 盈亏比改善 (高质量信号尾部更肥)
- ✅ 理论一致性 (符合信条,背景独立)

**负面**:
- ❌ 需要Cluster数据 (buy/sell分层)
- ❌ 增加计算复杂度
- ❌ 冷启动问题 (quality需要历史分布)
- ❌ 可能错过一些"弱但有效"的信号

**代价可接受理由**:
- Cluster数据本就在路线图中
- 计算复杂度增加 < 10%
- 冷启动用初始阈值 (如0.5)
- "少做精做"优于"多做对一半"

### 替代方案

**方案A: 保持单值,只调整阈值**
```python
if E > 0.60:  # 提高阈值
    开仓
```
- 优点: 实现简单,无需Cluster
- 缺点: 治标不治本,无法根本区分质量
- **拒绝理由**: 无法解决"80%低质量"的根本问题

**方案B: 用机器学习预测quality**
```python
quality = ML_model.predict(features)
```
- 优点: 可能更准确
- 缺点: 
  - 违反奥卡姆剃刀 (过度复杂)
  - 可解释性差
  - 需要大量标注数据
  - 过拟合风险高
- **拒绝理由**: 与MIF"可解释+可证伪"的理念冲突

**方案C: 多重过滤 (保持E单值,增加额外条件)**
```python
if E > 0.40 and CVD > threshold and volume > threshold:
    开仓
```
- 优点: 不改E定义
- 缺点: 条件割裂,不成体系
- **拒绝理由**: 不如直接将质量纳入E的定义更简洁

### 验证方法

**Phase 2回测验证**:
- [ ] 计算E.quality与后续收益的相关性
  - 预期: corr > 0.3, p < 0.05
  - 证伪条件: corr < 0.1

- [ ] 对比top 20% vs bottom 80% quality的胜率
  - 预期: top 20%胜率 > 40%, bottom 80%胜率 < 15%
  - 证伪条件: 两组无显著差异 (p > 0.05)

- [ ] 回测对比: DOM代理 vs Cluster真实
  - 预期: Cluster版本夏普提升 > 0.2
  - 证伪条件: 提升 < 0.05

### 实施计划

**Phase 1** (本周):
- [x] 设计E三维结构
- [x] 定义quality计算公式
- [x] 修复Cluster数据提取
- [ ] 导出完整Cluster字段

**Phase 2** (下周):
- [ ] 实现quality计算 (Python)
- [ ] 回测验证
- [ ] 调整权重 (0.4/0.3/0.3)

**Phase 3** (两周后):
- [ ] 如验证通过,全面替换旧E
- [ ] 如验证失败,回退或调整

### 重新评估条件

**如果发生以下情况,重新考虑此决策**:
1. Phase 2验证: E.quality与收益相关性 < 0.1
2. Cluster数据提取失败或质量极差 (覆盖率 < 70%)
3. 计算开销过大 (回测时间 > 10x)
4. 发现更简单的质量评估方法

---

## ADR-002: 使用分位数而非硬阈值

**日期**: 2025-11-09  
**状态**: 🔄 Partial (Phase 1部分实现,Phase 2全面推广)  
**决策者**: Severi + Claude

### 上下文

**问题**:
- 策略中多处使用硬阈值
  - Ω门控: 0.68
  - u边缘: 0.3, 0.7
  - D主导: -0.25, +0.25
  - divergence: 0.3
- 这些硬阈值的来源:
  - 经验拍脑袋
  - 或初期回测的偶然结果
  - 未考虑不同市场/regime的差异

**问题表现**:
```
BTCUSDT牛市: Ω=0.68可能太低 (噪音多)
BTCUSDT熊市: Ω=0.68可能太高 (错过机会)
ETHUSDT: 波动率不同,阈值可能完全不适用
```

**理论冲突**:
- 违反**策略信条1**: 关系优于点
- 违反**背景独立性**: 理论量应不依赖具体市场特性

### 决策

**采用方案**: 所有阈值改为历史分位数
```python
# Before (硬阈值)
if Ω > 0.68:
    pass

# After (分位数)
Ω_threshold = quantile(Ω_history, 0.68)
if Ω > Ω_threshold:
    pass
```

**具体转换表**:

| 参数 | 旧值 (硬阈值) | 新值 (分位数) |
|------|-------------|-------------|
| Ω门控 | 0.68 | quantile(Ω, 0.68) |
| Ω强信 | 0.95 | quantile(Ω, 0.95) |
| u下沿 | 0.3 | quantile(u, 0.3) |
| u上沿 | 0.7 | quantile(u, 0.7) |
| D (Belief) | -0.25 | quantile(D[D<0], 0.25) |
| D (Struct) | +0.25 | quantile(D[D>0], 0.75) |
| divergence | 0.3 | quantile(\|div\|, 0.75) |

### 理由

**1. 背景独立性**
```
不同市场Ω的分布不同:
- BTCUSDT高波动: Ω均值0.55, std 0.15
- ETHUSDT中波动: Ω均值0.60, std 0.12

硬阈值0.68:
- BTC: 68%分位 (合理)
- ETH: 85%分位 (过严)

分位数0.68:
- BTC: 自动适应到0.68值
- ETH: 自动适应到0.72值
```

**2. Regime自适应**
```
牛市regime: Ω整体上移
- 硬阈值0.68 → 太多信号 (质量下降)
- 分位数0.68 → 自动上调阈值 (保持质量)

熊市regime: Ω整体下移
- 硬阈值0.68 → 信号太少 (错过机会)
- 分位数0.68 → 自动下调阈值 (保持机会)
```

**3. 符合关系论**
```
信条1: 关系优于点
- 硬阈值: 用绝对位置
- 分位数: 用相对位置

Ω=0.70的"意义"不在于数值本身
而在于它在历史分布中的相对位置
```

### 后果

**正面**:
- ✅ 跨市场适用性大幅提升
- ✅ Regime切换时自动调整
- ✅ 理论一致性 (符合背景独立)
- ✅ 可证伪性强 (可比较硬阈值vs分位数)

**负面**:
- ❌ 需要足够历史数据 (建议100+ bars)
- ❌ 冷启动问题 (初期无历史)
- ❌ 分位数计算增加少量开销
- ❌ 极端regime下可能失效

**缓解措施**:
```python
# 冷启动: 初期用硬阈值
if len(Ω_history) < 100:
    Ω_threshold = 0.68  # fallback
else:
    Ω_threshold = quantile(Ω_history, 0.68)

# 极端regime: 设置边界
Ω_threshold = clip(
    quantile(Ω_history, 0.68),
    min=0.50,  # 下界
    max=0.90   # 上界
)
```

### 替代方案

**方案A: 自适应阈值 (基于波动率)**
```python
Ω_threshold = f(realized_volatility)
```
- 优点: 更精细
- 缺点: 增加复杂度,不确定f的形式
- **拒绝理由**: 分位数已经自动适应波动率

**方案B: 机器学习阈值**
```python
threshold = ML_model.predict(market_features)
```
- 优点: 可能最优
- 缺点: 过度复杂,不可解释
- **拒绝理由**: 违反奥卡姆剃刀

**方案C: 固定阈值,但多市场校准**
```python
if symbol == "BTCUSDT":
    Ω_threshold = 0.68
elif symbol == "ETHUSDT":
    Ω_threshold = 0.72
```
- 优点: 简单
- 缺点: 不scalable,需要每个市场单独校准
- **拒绝理由**: 不符合背景独立性

### 验证方法

**A/B测试**:
- [ ] 样本内: 硬阈值 vs 分位数的夏普比
  - 预期: 分位数夏普提升 > 0.1
  
- [ ] 样本外: 30天hold-out测试
  - 预期: 分位数稳健性更好 (夏普衰减 < 20%)
  
- [ ] 跨市场: BTCUSDT vs ETHUSDT
  - 预期: 硬阈值衰减 > 30%, 分位数衰减 < 15%

**证伪条件**:
- 如果分位数在所有测试中都不优于硬阈值
- 如果极端regime导致分位数完全失效 (>50%的bars)
- 如果冷启动问题无法解决

### 实施计划

**Phase 1** (本周) - 部分实施:
- [x] Ω门控改为分位数
- [x] E.quality改为分位数
- [ ] 实现冷启动逻辑
- [ ] 实现边界clip

**Phase 2** (下周) - 全面推广:
- [ ] D阈值改为分位数
- [ ] divergence改为分位数
- [ ] 回测验证

**Phase 3** (两周后) - u边缘动态化:
- [ ] u_edge = f(w_box, quantile)
- [ ] 最复杂,单独处理

### 重新评估条件

**如果**:
1. A/B测试: 分位数无显著优势 (p > 0.1)
2. 极端regime频繁触发边界clip (> 30% bars)
3. 冷启动导致初期表现极差 (前100 bars胜率 < 5%)

**则**: 考虑混合方案 (正常时用分位数,异常时fallback硬阈值)

---

## ADR-003: 固定30m窗口 vs 动态选择

**日期**: 2025-11-09  
**状态**: ⚠️ Deferred (Phase 1固定,Phase 3重新评估)  
**决策者**: Severi + Claude

### 上下文

**理论上的最优方案**:
```
根据协变强度动态选择交易窗口:
- 协变极强 (>q95) + Ω>0.85 → 15m快速收割
- 协变中等 → 30m标准窗口
- 协变弱但Ω极高 → 1h耐心持有
```

**担忧**:
- 动态选择 = 3个自由参数 (15m/30m/1h切换规则)
- 自由度过高 → 过拟合风险
- 样本内完美适应 → 样本外完全失效

**历史教训**:
- 很多策略在回测时"聪明地"选择窗口
- 实盘时切换逻辑失效
- 类似"用昨天的波动率预测今天"的陷阱

### 决策

**Phase 1-2采用**: 固定30m窗口

**Phase 3重新评估**: 如果固定30m有效,再考虑动态化

### 理由

**1. 最小路径原则**
```
Phase 1目标: 验证核心逻辑 (E三维化, 动态门控)
不应同时优化: 核心逻辑 + 窗口选择

类比:
先确保"引擎能转"
再优化"转速控制"
```

**2. 30m是稳健中位**
```
1m: 噪音主导 (60%+ bars是噪音)
5m: 仍有较多假突破
15m: 质量提升,但可能过快
30m: ✓ 平衡速度与稳定性
1h: 稳定,但机会少

30m在1m-1h范围的几何中点
```

**3. 降低过拟合风险**
```
固定窗口:
- 1个参数 (30m)
- 无法"选择性适应"历史
- 迫使策略逻辑更鲁棒

动态窗口:
- 3+个参数 (切换规则)
- 可能"记忆"历史
- 策略逻辑可能脆弱
```

**4. 可证伪性**
```
固定30m失败 → 问题在核心逻辑
动态窗口失败 → 不知道是逻辑还是切换规则的问题

先验证核心,再优化外围
```

### 后果

**正面**:
- ✅ 简化实现
- ✅ 降低过拟合风险
- ✅ 更容易定位问题
- ✅ 可作为baseline

**负面**:
- ❌ 可能错过15m的快速机会 (估计10-15%机会)
- ❌ 可能在1h级别过早退出 (估计5-10%利润)
- ❌ 理论上不是最优

**权衡**:
```
潜在收益损失: 10-20%
过拟合风险降低: > 50%

权衡是值得的
```

### 替代方案

**方案A: 动态窗口(多规则)**
```python
if Ω > 0.85 and 协变 > q95 and dΩ/dt > 0:
    window = "15m"
elif Ω < 0.7 and Ω > 0.68 and 长期趋势明确:
    window = "1h"
else:
    window = "30m"
```
- 优点: 理论上最优
- 缺点: 5+个参数,过拟合风险极高
- **延迟理由**: Phase 1先验证核心

**方案B: 自适应窗口(基于volatility)**
```python
window = f(realized_volatility)
```
- 优点: 连续函数,参数少
- 缺点: f的形式不明确,仍需验证
- **延迟理由**: 同上

**方案C: 固定15m**
```python
window = "15m"  # 永远
```
- 优点: 最快
- 缺点: 可能过快,假阳性多
- **拒绝理由**: 30m更平衡

### 验证方法

**Phase 1-2**: 
- [ ] 固定30m回测,验证核心逻辑有效
  - 目标: 夏普 > 0.5, 胜率 > 25%

**Phase 3** (仅在Phase 1-2成功后):
- [ ] A/B测试: 固定30m vs 动态窗口
  - 样本内: 动态窗口夏普提升 > 0.2
  - 样本外: 动态窗口夏普衰减 < 20%
  
- [ ] 如果动态窗口显著优于固定 (p < 0.05)
  - 且样本外稳健
  - 则Phase 4采用动态窗口

**证伪条件**:
- 如果动态窗口样本外完全失效 (夏普 < 固定窗口)
- 如果优势不显著 (p > 0.1)
- 则放弃动态窗口,永久固定30m

### 实施计划

**Phase 1-2**: 
- [x] 固定30m
- [ ] 实现核心逻辑
- [ ] 回测验证

**Phase 3** (≥ 2周后,且Phase 1-2成功):
- [ ] 设计动态切换规则
- [ ] 实现A/B测试框架
- [ ] 样本内验证
- [ ] 样本外验证
- [ ] 决策: 采用 or 拒绝

### 重新评估条件

**立即重新评估,如果**:
1. Phase 1-2: 固定30m完全失败 (夏普 < 0.1)
2. 数据分析显示: 90%+的盈利来自15m或1h (30m无效)

**Phase 3重新评估,如果**:
1. Phase 1-2: 固定30m成功 (夏普 > 0.5)
2. 积累1000+样本
3. 有清晰的切换规则假设

**永不重新评估,如果**:
1. 动态窗口在Phase 3被证伪
2. 过拟合风险无法控制

---

## ADR模板 (供后续使用)

```markdown
## ADR-004: [标题]

**日期**: YYYY-MM-DD
**状态**: 🔄 Proposed
**决策者**: [Name]

### 上下文
[问题描述]

### 决策
[方案]

### 理由
1. ...
2. ...

### 后果
**正面**: ...
**负面**: ...

### 替代方案
**方案A**: ...

### 验证方法
- [ ] ...

### 实施计划
...

### 重新评估条件
...
```

---

## 决策状态说明

- ✅ **Accepted**: 已采用,正在实施
- 🔄 **Proposed**: 提议中,待讨论
- ⚠️ **Deferred**: 延迟决策,等待条件
- ❌ **Rejected**: 已拒绝
- 🗑️ **Deprecated**: 过时,已被新决策取代

---

## 快速索引

| ADR | 标题 | 状态 | 日期 |
|-----|------|------|------|
| ADR-001 | E三维化 | ✅ Accepted | 2025-11-09 |
| ADR-002 | 分位数阈值 | 🔄 Partial | 2025-11-09 |
| ADR-003 | 固定30m窗口 | ⚠️ Deferred | 2025-11-09 |

---

**使用指南**:
1. 遇到重大决策时,创建新ADR
2. 用ADR编号递增 (ADR-004, ADR-005...)
3. 决策后,更新状态
4. 验证完成后,记录结果
5. 如决策失效,创建新ADR替代并标记旧ADR为Deprecated

**记住**: ADR不是日记,是决策的"可追溯性证明"
